# Angular i18n Message Implementation Guide

**Summary:** This file covers topics related to "Angular i18n Message Implementation Guide". Key snippets include: Implementing i18n Component Example in TypeScript, i18n String Renderer Implementation in TypeScript, Generating i18n Message in Angular TypeScript, Parsed ICU Data Structure in Angular, Compiler-Generated Code for i18n with ng-template in Angular....

---

## Implementing i18n Component Example in TypeScript

**Description:** Example component showing i18n attribute usage and plural form handling in Angular templates. Demonstrates usage of i18n markers and template bindings.

```typescript
@Component({
  template: `
    <div i18n-title title="Hello {{name}}!" i18n>
      {{count}} is rendered as:
      <b *ngIf="exp">
        { count, plural,
            =0 {no <b title="none">emails</b>!}
            =1 {one <i>email</i>}
            other {{{count}} <span title="{{count}}">emails</span>}
        }
      </b>.
    </div>
  `
})
class MyComponent {
}
```

---

## i18n String Renderer Implementation in TypeScript

**Description:** Pseudo-code implementation showing how i18n strings are rendered by concatenating string parts and handling interpolations.

```typescript
function render18nString(i18nStringParts: string|number) {
  const accumulator:string[] = [];
  i18nStringParts.forEach(part => accumulate(part));
  return accumulatorFlush(sanitizer);

 /**
   * Collect intermediate interpolation values.
   */
  function accumulate(value: string|number): void {
    if (typeof value == 'number') {
      // if the value is a number then look it up in previous `i18nBind` location.
      value = lviewData[bindIndex + value];
    }
    accumulator.push(stringify(value));
  }

  /**
   * Flush final interpolation value.
   */
  function accumulatorFlush(sanitizer: null|((text: string)=>string) = null): string {
    let interpolation = accumulator.join('');
    if (sanitizer != null) {
      interpolation = sanitizer(interpolation);
    }
    accumulator.length = 0;
    return interpolation;
  }
}
```

---

## Generating i18n Message in Angular TypeScript

**Description:** This snippet shows the TypeScript representation of the i18n message generated by the Angular template compiler. It includes markers for dynamic content and pluralization.

```typescript
const MSG_div = `�0� is rendered as: �*3:1��#1:1�{�0:1�, plural,
  =0 {no <b title="none">emails</b>!}
  =1 {one <i>email</i>}
  other {�0:1� <span title="�0:1�">emails</span>}
}�/#1:1��/*3:1�.`;
```

---

## Parsed ICU Data Structure in Angular

**Description:** TypeScript representation of how Angular parses an ICU message into a structured object. The parsed structure includes the type of ICU (plural), the expression binding index, and the different case strings with HTML.

```typescript
const icu = {
  type: 'plural',             // or 'select'
  expressionBindingIndex: 0,  // from �0�,
  cases: [
    'no <b title="none">emails</b>!',
    'one <i>email</i>',
    '�0� <span title="�0�">emails</span>',
  ]
}
```

---

## Compiler-Generated Code for i18n with ng-template in Angular

**Description:** The Angular compiler-generated TypeScript code for handling i18n in an ng-template element. Shows how i18nStart and i18nEnd functions are used to handle translation without a common parent element.

```typescript
const MSG_text = 'Translated text';

function MyComponent_Template_0(rf: RenderFlags, ctx: any) {
  if (rf & RenderFlags.Create) {
    i18nStart(0, MSG_text, 1);
    i18nEnd();
  }
  ...
}
```

---

## TI18n Data Structure for ICU Attribute Binding in Angular

**Description:** Detailed TypeScript representation of the TI18n internal data structure used by Angular for ICU messages in attribute bindings. Contains create, update operation codes, and ICU case handling with expandoStartIndex and variable definitions.

```typescript
const tI18n = <TI18n>{
  vars: 0,                               // Number of slots to allocate in EXPANDO. (Max of all ICUs + fixed)
  expandoStartIndex: 200,                // Assume in this example EXPANDO starts at 200
  create: <I18nMutateOpCodes>[
    // attributes have no create block
  ],
  update: <I18nUpdateOpCodes>[
    // If `changeMask & 0b1`
    //        has changed then execute update OpCodes.
    //        has NOT changed then skip `2` values and start processing next OpCodes.
    0b1, 2,
    -1,       // accumulate(-1)
    // Switch ICU: `icuSwitchCase(lView[200 /*SHIFT_REF*/], 0 /*SHIFT_ICU*/, accumulatorFlush());`
    200 << SHIFT_REF | 0 << SHIFT_ICU | IcuSwitch,

    // NOTE: the bit mask here is the logical OR of all of the masks in the ICU.
    0b1, 4,
    'You have ',  // accumulate('You have ');

    // Update ICU: `icuUpdateCase(lView[200 /*SHIFT_REF*/], 0 /*SHIFT_ICU*/);`
    // SHIFT_REF: points to: `i18nStart(0, MSG_div, 1);`
    // SHIFT_ICU: is an index into which ICU is being updated. In our example we only have
    //            one ICU so it is 0-th ICU to update.
    200 << SHIFT_REF | 0 << SHIFT_ICU | IcuUpdate,

    '.',  // accumulate('.');

    // Update attribute: `elementAttribute(1, 'title', accumulatorFlush(null));`
    // NOTE: `null` means don't sanitize
    1 << SHIFT_REF | Attr, 'title', null,
  ],
  icus: [
    <TIcu>{
      cases: [0, 1, 'other'],
      vars: [0, 0, 0],
      expandoStartIndex: 200,                // Assume in this example EXPANDO starts at 200
      childIcus: [],
      create: [
        // Case: `0`: `{no emails}`
        <I18nMutateOpCodes>[ ]
        // Case: `1`: `{one email}`
        <I18nMutateOpCodes>[ ]
        // Case: `"other"`: `{�0� emails}`
        <I18nMutateOpCodes>[ ]
      ],
      remove: [
        // Case: `0`: `{no emails}`
        <I18nMutateOpCodes>[ ]
        // Case: `1`: `{one email}`
        <I18nMutateOpCodes>[ ]
        // Case: `"other"`: `{�0� emails}`
        <I18nMutateOpCodes>[ ]
      ],
      update: [
        // Case: `0`: `{no emails}`
        <I18nMutateOpCodes>[
          // If `changeMask & -1` // always true
          //        has changed then execute update OpCodes.
          //        has NOT changed then skip `1` values and start processing next OpCodes.
          -1, 1,
          'no emails',  // accumulate('no emails');
        ]
        // Case: `1`: `{one email}`
        <I18nMutateOpCodes>[
          // If `changeMask & -1` // always true
          //        has changed then execute update OpCodes.
          //        has NOT changed then skip `1` values and start processing next OpCodes.
          -1, 1,
          'one email',  // accumulate('no emails');
        ]
        // Case: `"other"`: `{�0� emails}`
        <I18nMutateOpCodes>[
          // If `changeMask & -1` // always true
          //        has changed then execute update OpCodes.
          //        has NOT changed then skip `1` values and start processing next OpCodes.
          -1, 2,
          -1,        // accumulate(lView[bindIndex-1]);
          'emails',  // accumulate('no emails');
         ]
      ]
    }
  ]
}
```

---

## Rendering i18n Elements in Angular HTML Template

**Description:** This snippet demonstrates an Angular template with i18n elements, including pluralization and conditional rendering. It shows how complex i18n structures are represented in HTML.

```html
<div i18n>
  {{count}} is rendered as:
  <b *ngIf="exp">
    { count, plural,
        =0 {no <b title="none">emails</b>!}
        =1 {one <i>email</i>}
        other {{{count}} <span title="{{count}}">emails</span>}
    }
  </b>.
</div>
```

---